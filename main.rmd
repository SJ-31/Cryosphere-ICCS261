```{r}
knitr::opts_chunk$set(eval = FALSE)
source("./all_artifacts.r")
```

# Overview

## Questions
- How distinct are different cryospheric environments as microbial habitats?
- What taxa are most associated with cryospheric environments? Do these differ between habitats?
- What is the diversity of biological pathways? Will we see distinct sets of functions for each habitat?

## Hypotheses
- We will observe greater taxonomic diversity between sites than functional diversity
- There is a limited number of adaptations that microorganisms can evolve to survive in cryospheric environments, so we should expect a signifcant degree of convergent evolution towards the same adaptive mechanisms
- There will be a set of biological processes shared between all cryospheric ecosystems, but not found in other places

# Importing data from fastq

Qiime2 uses a compressed type of file format called an 'Artifact' for its analyses. Artifacts have different semantic types e.g. `FeatureData[Sequence]`, `Phylogeny[Unrooted]` depending on the type of data they contain. To begin the analysis, I need to import my fastq files into `FeatureData[SequencesWithQuality]` or `FeatureData[PairedEndSequencesWithQuality]`.

Although all of these reads were prepared with Illumina devices, sequencing quality can vary between sequencing centres, meaning that each sample will likely need specific parameters for cleaning. Furthermore, two of the samples were sequenced with paired-end format. This means that I'll need to import each sample into different artifacts, merging them together once they have been cleaned. To reduce bias in sampling between sites, I have specifically looked for larger fastq files, then split them

Quality $(Q)$ is commonly measured in Phred scores, denoted as $Q=-10 \log_{10}P$, where $P$ is the probability of an incorrect base call. Therefore, higher values for Phred indicate a lower probability of an erroneous base. Every base position is given a Phred score, and it is common to see the score decrease the longer the read

```bash
# Relevant commands
qiime tools import \
  --type 'SampleData[PairedEndSequencesWithQuality]' \
  --input-path devon.tsv \
  --output-path devonFQ.qza \
  --input-format PairedEndFastqManifestPhred64V2

qiime tools import \
  --type 'SampleData[SequencesWithQuality]' \
  --input-path neem.tsv \
  --output-path neem.qza \
  --input-format SingleEndFastqManifestPhred33V2
```

# Taxonomic classifications
For sample taxonomic classification, I will be trying out all three of the methods available in qiime2:
```{r}
knitr::opts_chunk$set(eval = FALSE)
blast <- lapply(
  get_artifact_data("./results/3-Classified", id_key, "BLAST_All"),
  parse_taxonomy
)
sklearn <- lapply(
  get_artifact_data("./results/3-Classified", id_key, "Sklearn"),
  parse_taxonomy
)
sk_merged <- read_qza("./results/3-Classified/Merged-Sklearn.qza")$data %>%
  parse_taxonomy()
sklearn %>%
  lapply(., dim) %>%
  unlist(use.names = FALSE) %>%
  sum()
sk_merged %>% dim()
count_identified(sklearn, "Sklearn")
count_identified(blast, "BLAST")
# The sklearn classifier has a slightly better number of identifications so will be used for all any downstream analyses
```

## Database preparation

Two databases were obtained:

- All annotated 16S rRNA from the NCBI ftp [website](https://ftp-ncbi-nlm-nih-gov.ejournal.mahidol.ac.th/blast/db/v5/)
- Annotated 16S rRNA used by the tool [MicFunPred](https://github.com/microDM/MicFunPred)
- A 16S rRNA database from [EzBioCloud](https://www.ezbiocloud.net/dashboard)

The MicFunPred and NCBI databases were obtained in the standard BLAST format, and need to be converted into compatible data types for import into the qiime2 workflow. Specficially, I needed to convert them into FASTA format with an associated taxonomy mapping file (in HeaderlessTSVTaxonomyFormat)

- Steps
  - 1 Extract all entries from the database in FASTA format
  - 2 Extract the header and convert it into the HeaderLessTSVTaxonomyFormat, which is a tab-delimited file of FASTA identifiers followed by their taxonomic assignments
  - 3 Remove the taxonomic assignments from the original FASTA file
  - 4 Concatenate the respective files types together, then import them files as qiime2 Artifacts
  - 5 Repeat for the other database (if both databases used the identifier conventions I could have combined them and processed them together but unfortunately this was not the case )

```bash
# 1
blastdbcmd -db NCBI_16S/16S_ribosomal_RNA -entry all > NCBI_16S.fasta
blastdbcmd -db micfun/micfun16S -entry all > micfun.fasta

# 2
grep '>' NCBI_16S.fasta | tr -d '>' | sed 's/ /\t/' | sed 's/ /_/g' > NCBI_16SID.txt
grep '>' micfun.fasta | tr -d '>' | sed 's/_/\t/' | sort | uniq > micfunID.txt # Unfortunately several of the headers repeat

# 3
cat micfun.fasta | sed 's/_.*//' > micfunID.fasta
cat NCBI_16S.fasta | sed 's/ .*//' > ncbi16sID.fasta

# 4
cat micfunID.txt NCBI_16SID.txt EzBioCloud/ezbiocloud_id_taxonomy.txt > all_mappings.txt
cat EzBioCloud/ezbiocloud_qiime_full.fasta ncbi16sID.fasta micfun.fasta > all.fasta
qiime tools import     --type FeatureData[Taxonomy]     --input-format HeaderlessTSVTaxonomyFormat     --input-path all.fasta     --output-path all_fasta.qza
qiime tools import     --type FeatureData[Taxonomy]     --input-format HeaderlessTSVTaxonomyFormat     --input-path all_uniqIDs.txt     --output-path Ids.qza
```

- Altogether, the database contains 130,122 sequences (though there might be some repetition that was overlooked)

```python
# Script for removing redundant ids
from Bio import SeqIO
import csv

exists: set = set()
mapped = open('all_uniq.fasta', 'w+')
for seq in SeqIO.parse('all.fasta', 'fasta'):
    if seq.id in exists:
        continue
    exists.add(seq.id)
    mapped.write(f'>{seq.id}\n')
    mapped.write(f'{seq.seq}\n')
mapped.close

uniq = open('all_uniqIDs.txt', 'w+')
exists2: set = set()
with open('all_mappings.txt', 'r') as i:
    for id in csv.reader(i, delimiter='\t'):
        if id[0] in exists2:
            continue
        exists2.add(id[0])
        uniq.write(f'{id[0]}\t{id[1]}\n')
uniq.close
```

### Phylogenetic trees
```{r}
knitr::opts_chunk$set(eval = FALSE)
otu_freqs <- lapply(
  get_artifact_data("./results/2-OTUs", id_key, "otuFreqs"),
  as.data.frame
)
fasttree <- get_artifact_data(
  "./results/6-RootedTrees", id_key,
  "FastTree_RootedTree"
)
iqtree <- get_artifact_data(
  "./results/6-RootedTrees", id_key,
  "IQTREE_RootedTree"
)
matched <- match(iqtree$GrI$tip.label, rownames(otu_freqs$GrI))
freq_mapping <- otu_freqs$GrI[matched, ] %>%
  rowMeans() %>%
  as.data.frame() %>%
  `rownames<-`(seq_along(rownames(.)) %>% paste("OTU", ., sep = ""))
iqtree$GrI$tip.label <- paste(rownames(freq_mapping), "freq =", freq_mapping[[1]])
sample_tree <- iqtree$GrI %>%
  ggtree(layout = "roundrect", aes(color = "#A4E473")) +
  geom_tiplab(size = 3, color = "#004651") +
  geom_tippoint(color = "#66CC8A")
sample_tree
ggsave("./figures/sample_tree.png", sample_tree,
  width = 10, height = 10,
  dpi = 500
)
```

### Import frequency tables

The following snippet maps otu ids the genus-level identifications for use with the farprotax database, writing csv files for each.
```r
otu_genus <- list()
for (id in names(id_key)) {
  otu_genus[[id]] <- to_genus_csv(otu_freqs[[id]], blast[[id]])
}
genus_combined <- combine_freqs(otu_genus, taxon)
write.csv(combined, "genus_otu_tables.csv", row.names = FALSE)
```

# Diversity analyses
- Unweighted "qualitative" metrics do not consider OTU abundance, telling you only about the presence and abundance of OTUs. They are more sensitive to rare OTUs
- Weighted "quantitative" metrics consider relative OTU abundance, and are more sensitive to abundant taxa
- Non-phylogenetic metrics assume everything is equally related to each other, so the presence of closely related species would contribute to higher diversity
- Phylogenetic metrics take into account similarity based on evolutionary relation, resulting in better scaling for genetic distance


## Alpha diversity
```{r}
knitr::opts_chunk$set(eval = FALSE)
alpha <- get_artifact_data("./results/7-Diversity",
  id_key,
  extension = "",
  metric_list = alpha_metrics
)
pi_evenness <- data.frame(row.names = 1:10)
for (site in names(id_key)) {
  pi_evenness[[id_key[[site]]]] <- alpha[[site]]$pi[, 1]
}
shannon <- data.frame(row.names = 1:10)
for (site in names(id_key)) {
  shannon[[id_key[[site]]]] <- alpha[[site]]$sh[, 1]
}
even_plot <- pi_evenness %>%
  gather() %>%
  ggplot(aes(x = key, y = value, fill = key)) +
  geom_boxplot() +
  guides(fill = "none") +
  labs(x = "Site", y = "Evenness", title = "Pielou evenness")
entropy_plot <- shannon %>%
  gather() %>%
  ggplot(aes(x = value, y = key, fill = key)) +
  ggridges::geom_density_ridges2() +
  guides(fill = "none") +
  labs(y = "Site", x = "Shannon Entropy")
ggsave("./figures/entropy.png", entropy_plot, width = 20, height = 10, dpi = 500)
ggsave("./figures/Pielou_evenness.png", even_plot, width = 20, height = 10, dpi = 500)
```
From the box plot, we can see a few of the sites having similar evenness, particularly the Barrow mountain sites, Bihor mountains and Catriona snow. Whether or not the difference in Pielou evenness is statistically significant can be tested with Kruskal wallis
```{r}
knitr::opts_chunk$set(eval = FALSE)
pi_evenness %>%
  select(c(
    "Barrow mountain high", "Barrow mountain low",
    "Bihor mountains", "Catriona snow"
  )) %>%
  kruskal.test()
```
The p-value is 0.2744, so the difference in evenness is not statistically significant

## Beta diversity
All ordination plots will be carried out with PCOA
```{r}
knitr::opts_chunk$set(eval = FALSE)
beta <- get_artifact_data("./results/7-Diversity",
  list(Merged = NULL),
  extension = "",
  metric_list = beta_metrics
)
pcoa2D <- get_artifact_data("./results/8-Analysis",
  list(Merged = NULL),
  extension = "PCOA-2D_",
  metric_list = beta_metrics
)
pcoa2D_merged <- lapply(pcoa2D$Merged, metadata_merge_pcoa, metadata = metadata)
pcoaja <- plot_pcoa(pcoa2D_merged$ja, "Location",
  title = "Jaccard distance"
)
pcoabc <- plot_pcoa(pcoa2D_merged$bc, "Location",
  title = "Bray Curtis"
)
pcoauu <- plot_pcoa(pcoa2D_merged$uu, "Location",
  title = "Unweighted Unifrac",
)
pcoawn <- plot_pcoa(pcoa2D_merged$wn, "Location",
  title = "Weighted Normalized Unifrac ",
)
pcoa_arrange <- ggarrange(pcoabc, pcoauu, pcoawn,
  ncol = 3,
  common.legend = TRUE,
  legend = "right"
)
ggsave("./figures/pcoas.png",
  plot = pcoa_arrange,
  dpi = 300, width = 20, height = 10
)
```
The pcoa plots depict clearly how the choice of distance metric affects the clustering of samples.
- Clustering in the Bray Curtis plot represents sites sharing many of the same species and in similar abundances. The big cluster falls apart once we factor the evolutionary distance between OTUs, shown by the Unifrac metrics.
    - This implies that although some taxa are shared, the unique taxa are a evolutionary distant (essentially have very different DNA) from the shared ones.
- Once we add weightings by abundance though, new clusters form, indicating there are many more common taxa within the groups than there are unique taxa.
- Even partitioning sites by habitat type - glacier and permafrost, doesn't help

Admittedly, there is no clear consensus on what metric to choose when the results disagree strongly with each other. For the scope of this project, I will focusing the rest of the analyses only on the cluster depicted in the unweighted unifrac plot consisting of Cryoconite, Bihor Mountain caves, Yakutia, East Iceland glaciers, Catriona snow, and Greenland ice.
```{r}
knitr::opts_chunk$set(eval = FALSE)
# Filter the sites
# keep <- c("BhM", "CrC", "CaS", "CeY", "GrI", "EaI")
keep <- c("ViS", "BrL", "BrH", "SvG")
# keep <- c("CaS", "CeY", "BhM", "EaI")
# filter_uu <- filter_dm(beta$Merged$uu, keep)
filter_wn <- filter_dm(beta$Merged$wn, keep)
# filter_bc <- filter_dm(beta$Merged$bc, keep)
filtered_meta <- filter_meta(metadata, keep)
```

### PERMANOVA & ANOSIM
Within the chosen cluster, its visually unclear whether or not the differences between sites are significant. There are specific hypothesis tests for this problem, such as Permutational Analysis of Variance (PERMANOVA) and Analysis of Similarities (ANOSIM)

They can be thought of as quantitative extensions to ordination plots of a distance measure: it allows you to say with confidence whether or not certain variables (in this case location) are generating a statistically significant difference between species composition

Both PERMANOVA and ANOSIM test the null hypothesis that within-group distances from each group are identical to between-group distance. With this dataset, rejecting the null hypothesis and concluding that between-group distance is different from within-group distance will let us conclude that different locations do have statistically significant species distribution.
- The difference between them is...
TODO:what is the difference between them?

```{r}
knitr::opts_chunk$set(eval = FALSE)
# adonis2(filter_uu ~ filtered_meta$Location)
adonis2(filter_wn ~ filtered_meta$Location)
# adonis2(filter_bc ~ filtered_meta$Location)
# anosim(filter_uu, grouping = filtered_meta$Location)
anosim(filter_wn, grouping = filtered_meta$Location)
```

# Functional analysis
The raw output tables here are the absolute abundances of inferred biological pathways in each site based on the MetaCyc database. PICRUSt2 works by first predicting important reactions for metabolism in the site (using KEGG Orthology (KO) and Enzyme Commission numbers (EC)) format, then using their abundances for pathway inference. A pathway is essentially a set of reactions working together for a specific purpose, such as energy storage or synthesis.
- Originally I had planned to use the farprotax database, but the script the authors provided didn't work.
- I encountered another problem where PICRUSt2 failed to analyze the merged dataset so I had to combine the output tables from each sample.

```{r}
knitr::opts_chunk$set(eval = FALSE)
ko_all <- ko %>%
  # Merge the PICRUSt2 tables
  reduce(merge, by = "pathway", all = TRUE) %>%
  as_tibble() %>%
  replace(is.na(.), 0) %>%
  rel_abund(., pathway) %>% # Convert to relative abundances
  as_tibble()
ko_all %>% dim() # There are 438 inferred pathways

ko_xfunc <- ko_all %>% sites_x_func() # Transpose into sites x function format

# Compute bray curtis distance, then plot pcoa
bc_func <- vegdist(ko_xfunc, method = "bray")
pcoa_bc_func <- bc_func %>%
  wcmdscale(k = 2) %>%
  metadata_merge_pcoa(metadata, ., functions = TRUE)
# Compute jaccard distance
ja_func <- vegdist(ko_xfunc, method = "jaccard")
pcoa_ja_func <- ja_func %>%
  wcmdscale(k = 2) %>%
  metadata_merge_pcoa(metadata, ., functions = TRUE)

# Plot and compare with ordination on taxonomy
plot_ja_func <- plot_pcoa(pcoa_ja_func, "Location",
  title = "Jaccard distance",
  subtitle = "From biological pathways", functions = TRUE
)
plot_bc_func <- plot_pcoa(pcoa_bc_func, "Location",
  title = "Bray Curtis",
  subtitle = "From biological pathways", functions = TRUE
)
func_compare <- ggarrange(plot_ja_func, pcoaja, plot_bc_func, pcoabc,
  ncol = 2, nrow = 2, common.legend = TRUE, legend = "bottom"
)
ggsave("./figures/func_vs_tax.png",
  plot = func_compare,
  dpi = 300, width = 20, height = 10
)
```

# Differential abundance analysis
Finally, I will perform tests on the abundance of identified OTUs and the predicted pathways in the previously selected sites. Differential abundance analysis this refers to identifying which otus are more or less present between different samples. Traditional statistical tests are inappropriate for this application generally because the data is so sparse.

I will be using the Analysis of Microbiomes with Bias correction test (ANCOM-BC). To get an idea of what to expect from the test, I'll produce a bar plot depicting the relative phylum-level abundances between the sites.

```{r}
knitr::opts_chunk$set(eval = FALSE)
all <- read_qza("./results/2-OTUs/Merged-otuFreqs.qza")$data
sk_merged <- read_qza("./results/3-Classified/Merged-Sklearn.qza")$data %>%
  parse_taxonomy()

ranks <- merge_with_id(all, sk_merged, level = 2) %>%
  filter(!(is.na(taxon))) %>%
  group_by(taxon) %>%
  summarise(across(everything(), sum))

not_bacteria <- c(
  "Arthropoda", "Nanoarchaeota", "Diatomea", "Altiarchaeota",
  "Ascomycota", "Basidiomycota", "Cercozoa", "Ciliophora", "Asgardarchaeota",
  "Phragmoplastophyta", "Euryarchaeota", "Crenarchaeota"
)

shown_paths <- c(
  "CHLOROPHYLL-SYN", "GLYCOLYSIS", "TCA", "CALVIN-PWY",
  "PENTOSE-P-PWY", "METHANOGENESIS-PWY", "DENITRIFICATION-PWY", "FERMENTATION-PWY",
  "LACTOSECAT-PWY", "METH-ACETATE-PWY"
)
nice_paths <- ko_all %>%
  filter((grepl(paste(shown_paths, collapse = "|"), pathway)))

tax_sum <- sum_by_site(ranks, id_key, "taxon", not_bacteria)
path_sum <- sum_by_site(nice_paths, id_key, "pathway", NaN)

stacked <- tax_sum %>% ggplot(., aes(x = name, y = value, fill = identifier)) +
  geom_bar(stat = "identity") +
  scale_fill_discrete(name = "Phylum") +
  scale_color_paletteer_d("pals::glasbey") +
  labs(
    x = "Site", y = "Relative abundance",
    subtitle = "*Putative phyla and false positives
  (non-prokaryotes) removed"
  )
ggsave("./figures/phyla.png", stacked, width = 20, height = 10, dpi = 300)

heat_path <- path_sum %>% ggplot(., aes(x = name, y = identifier, fill = value)) +
  geom_tile() +
  scale_fill_gradient2(
    name = "Relative abundance",
    mid = "seagreen1", low = "springgreen", high = "seagreen"
  ) +
  labs(
    x = "Site", y = "Pathway",
  )
ggsave("./figures/path_plot.png", heat_path, width = 20, height = 10, dpi = 300)
```
Going to the second-most inclusive taxonomic rank was essential here, given that there are 10668 OTUs total. Still, I noticed there were a few identifications that weren't prokaryotic. These are most likely false positives, given the specificity of the 16s rRNA primers used to sequence the samples.

From the plot, the
TODO:Which look abundant?

There wouldn't be much point to testing differential abundance for sites that we already know to be similar based on the weighted unifrac plots, so I stuck with the cluster of sites that ANOSIM and PERMANOVA were conducted on
```{r}
knitr::opts_chunk$set(eval = FALSE)
# First we prepare the TreeSummarizedExperiment object
tax_info <- c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species")
wrong_tax <- c("Unassigned", "Arthropoda", "Bacteria", "Insecta")

filtered_otus <- read_qza("./results/2-OTUs/Merged-otuFreqs.qza")$data %>%
  as.data.frame() %>%
  select(matches(keep))

chosen_paths <- ko_all %>%
  select(c(1, matches(keep))) %>%
  column_to_rownames(., var = "pathway")
formatted_meta_paths <- filtered_meta[match(colnames(chosen_paths), filtered_meta$sample.id), ] %>%
  `rownames<-`(NULL) %>%
  column_to_rownames(., var = "sample.id") %>%
  sample_data()
phylo_path <- phyloseq(
  otu_table(chosen_paths, taxa_are_rows = TRUE),
  formatted_meta_paths
)

matched_tax <- sk_merged[match(
  rownames(filtered_otus),
  rownames(sk_merged)
), ] %>%
  tax_table() %>%
  `colnames<-`(tax_info)

# All of this is necessary because the TSE object won't be
#   created properly unless the indices of the rownames match precisely
formatted_meta <- filtered_meta[match(colnames(filtered_otus), filtered_meta$sample.id), ] %>%
  `rownames<-`(NULL) %>%
  column_to_rownames(., var = "sample.id") %>%
  sample_data()
rownames(filtered_otus) <- rownames(matched_tax)
my_phylo <- phyloseq(
  otu_table(filtered_otus, taxa_are_rows = TRUE), formatted_meta,
  matched_tax
)

tse <- mia::makeTreeSummarizedExperimentFromPhyloseq(my_phylo)
# Now run the test, testing differential abundance between locations
tse_paths <- mia::makeTreeSummarizedExperimentFromPhyloseq(phylo_path)
```

```{r}
chosen_rank <- "Class"
abc <- ancombc2(
  data = tse, assay_name = "counts", tax_level = chosen_rank,
  fix_formula = "Location"
)
```

```{r}
abc_paths <- ancombc2(
  data = tse_paths, assay_name = "counts", tax_level = "Species",
  fix_formula = "Location"
)
```

### Plotting taxonomy
```{r}
knitr::opts_chunk$set(eval = FALSE)
abc_res <- abc$res %>% select(-(grep("Intercept", colnames(abc$res))))
diff_abund <- ancombc_select(abc_res, "diff_Location", chosen_rank, wrong_tax)
se <- ancombc_select(abc_res, "se_Location", chosen_rank, wrong_tax)
lfc <- ancombc_select(abc_res, "lfc_Location", chosen_rank, wrong_tax) %>%
  merge(se, by = c("name", "taxon")) %>%
  merge(diff_abund, by = c("name", "taxon")) %>%
  filter(diff_Location == TRUE) # Don't want to show taxa that don't have statistically
# signifcant differences in log fold change
percent_abund <- dim(lfc)[1] / dim(se)[1]

# We keep the taxa with the highest and lowest log-fold changes between sites
lfc_stats <- lfc$lfc_Location %>% summary()
lfc_q3 <- lfc_stats[["3rd Qu."]]
lfc_q1 <- lfc_stats[["1st Qu."]]

lfc <- lfc[lfc$lfc_Location > lfc_q3 | lfc$lfc_Location < lfc_q1, ]
message(glue("Percent of differentially abundant {chosen_rank}: {percent_abund}"))
abc_plot <- abc_lfc_plot(lfc) + scale_fill_discrete(name = "Class")
ggsave("./figures/abc_tax.png", abc_plot, width = 20, height = 10, dpi = 500)
```

### Plotting pathways
```{r}
knitr::opts_chunk$set(eval = FALSE)
abc_res_paths <- abc_paths$res %>%
  select(-(grep("Intercept", colnames(abc_paths$res))))
path_diff_abund <- ancombc_select(abc_res_paths, "diff_Location")
path_se <- ancombc_select(abc_res_paths, "se_Location")
path_lfc <- ancombc_select(abc_res_paths, "lfc_Location") %>%
  merge(path_se, by = c("name", "taxon")) %>%
  merge(path_diff_abund, by = c("name", "taxon")) %>%
  filter(diff_Location == TRUE)

lfc_stats <- path_lfc$lfc_Location %>% summary()
lfc_q3 <- lfc_stats[["3rd Qu."]]
lfc_q1 <- lfc_stats[["1st Qu."]]

percent_abund <- dim(path_lfc)[1] / dim(path_se)[1]
path_lfc <- path_lfc[path_lfc$lfc_Location > lfc_q3 | path_lfc$lfc_Location < lfc_q1, ]
message(glue("Percent of differentially abundant pathways: {percent_abund}"))
abc_pathways <- abc_lfc_plot(path_lfc) + scale_fill_discrete(name = "Pathway")
ggsave("./figures/abc_paths.png", abc_pathways, width = 20, height = 10, dpi = 500)
``````

- ANCOM volcano plot interpretation
  - ANCOM works by essentially doing a pairwise comparisons of the abundance of a given species in one sample vs a another sample
  - The W value for the *i*th species is the number of times that the null hypothesis is rejected for that species _i_. We can simply interpret higher W values to mean that a specie is more abundant than others.
The test can be thought of as ANOVA in that it identifies taxa that are differentially abundant between at least two groups across a set
- ANCOM-BC returns five metrics for each OTU:
    - Log fold change across different sites
    - W-score: log fold change across different sites divided by standard error. This is ANCOM-BC's test statistic
    - p value: whether or not the log fold change for a given OTU is statitically significant
    - q value: the adjusted p-values
    - Standard error

# References
