### Load functions and libraries

```{r}
library(ape)
library(ggtree)
library(TreeDist)
library(phyloseq)
library(tidyverse)
library(glue)
library(qiime2R)

metadata <- read.delim("./sys_metadata.tsv", sep = "\t")[-1, ]
map_meta <- metadata[["source"]] %>% `names<-`(metadata[["sample.id"]])
alpha_metrics <- list(
  sh = "shannon", pi = "pielou_e",
  si = "simpson", se = "simpson_e"
)

unique_known <- function(otus, identified, classifier) {
  uniques <- identified %>%
    group_by(taxon) %>%
    summarise() %>%
    dim()
  msg <- "% Unique otus:"
  prop <- round((uniques[1] / dim(otus)[1]) * 100, 2)
  return(glue("{classifier} {msg} {prop}"))
}

get_artifact_data <- function(path, ids, extension) {
  # Generic import function for artifact data
  artifacts <- list()
  for (id in names(ids)) {
    a_path <- glue("{path}/{id}-{extension}.qza")
    artifacts[[id]] <- read_qza(a_path)$data
  }
  return(artifacts)
}

known_taxon <- function(row, taxonomy) {
  known_rank <- 7
  while (is.na(taxonomy[row, known_rank]) && known_rank != 1) {
    known_rank <- known_rank - 1
  }
  return(taxonomy[row, known_rank])
}

genus_level <- function(row, taxonomy) {
  if (is.na(taxonomy[row, 7])) {
    return(taxonomy[row, 6])
  }
  return(taxonomy[row, 7])
}

identify <- function(taxonomy, otus) {
  return(
    lapply(1:nrow(taxonomy), known_taxon, taxonomy = taxonomy) %>%
      unlist() %>%
      data.frame(row.names = rownames(blast), taxon = .) %>%
      merge(., otus, by = 0) %>%
      drop_na()
  )
}
```
### Jellyfish microbiome analysis


### Sample background
The data is the microbiome of the arms

#### Importing the data

The fastq files contain single-end reads, sequenced with the 454 GS FLX+ via a pyrosequencing approach
https://trace.ncbi.nlm.nih.gov/Traces/study/?acc=SRP254518&o=acc_s%3Aa&s=SRR11447095,SRR11447093,SRR11447098

```{bash}
qiime tools import \
    --type 'SampleData[SequencesWithQuality]' \
    --input-path data.tsv \
    --output-path jelly.qza \
    --input-format SingleEndFastqManifestPhred33V2
```
### Raw data exploration

The initial data exploration was performed with fastqc. There is a high variation in read length, though the majority are in the 450 - 500 bp range. As expected for short-read sequencing, read quality drops at higher read lengths, necessitating trimming. Surprisingly, the sample has little adapter content.

#### Blasting overrepresenting sequences

To get a rough idea of what microorganisms were represented most in the sample, I used data from `fastqc`'s overrepresented sequences module.
The sequences listed in the module were combined, clustered together to remove redundant reads with `cd-hit`, then blasted against the custom 16s rRNA database.

- `cd-hit` grouped 238 overrepresented sequences from the 7 samples into only 17 clusters
- The following describes the best 3 hits for the top 3 most overrepresented sequences
  - 1. Entoplasma, Mesoplasma, Lebetimonas
  - 2. _Ferruginivarius sediminum_, Azospirillum, Desulfosporosinus
  - 3. Flavobacteria, Dokdonia, Joostella

### Taxonomic classification
For taxonomic classification, I tried out all three of the options offered by qiime2: blast, vsearch and pre-trained naive-bayes classifier. 

### Import results

```{r}
otus <- read_qza("./results/2-OTUs/Jelly-otuFreqs.qza")$data
blast <- read_qza("./results/3-Classified/Jelly-BLAST_All.qza")$data %>%
  parse_taxonomy()
sklearn <- read_qza("./results/3-Classified/Jelly-Sklearn.qza")$data %>%
  parse_taxonomy()
vsearch <- read_qza("./results/3-Classified/Jelly-Vsearch_All.qza")$data %>%
  parse_taxonomy()
iqtree <- read_qza("./results/6-RootedTrees/Jelly-IQTREE_RootedTree.qza")$data
b_known <- identify(blast, otus)
unique_known(otus, b_known, classifier = "BLAST")
sk_known <- identify(sklearn, otus)
unique_known(otus, sk_known, classifier = "Sklearn")
v_known <- identify(vsearch, otus)
unique_known(otus, v_known, classifier = "Vsearch")
wrong_stuff <- c("uncultured", "Chloroplast", "Mitochondria", "Unknown")
```

Simply by looking at the proportion of identified, unique otus, we can see that the machine-learning approach is more effective than the homology-based methods (it's also far lighter on computer resources). I'll use the sklearn identifications for the rest of the analysis. 

### Phylogenetic tree

```{r}
iqtree$tip.label <- sk_known$taxon[iqtree$tip.label %in% sk_known$Row.names]
tree <- ggtree(iqtree) + geom_tiplab(size = 3, color = "blue") +
  geom_rootedge(rootedge = .3)
tree
```

### Taxonomic analysis
```{r}
# Which genera were most abundant?
summed_otus <- otus %>%
  merge(., sklearn, by = 0) %>%
  drop_na() %>%
  select(c(Genus, J1, J2, J3)) %>%
  group_by(Genus) %>%
  summarize(across(everything(), sum))

row_abund <- function(column) {
  return(
    lapply(column, function(x) {
      x / sum(column)
    }) %>% unlist()
  )
}

rel_abund <- summed_otus %>%
  select(c(J1, J2, J3)) %>%
  lapply(., row_abund) %>%
  bind_rows() %>%
  mutate(Genus = summed_otus$Genus) %>%
  filter(!(grepl(paste(wrong_stuff, collapse = "|"), Genus))) %>%
  pivot_longer(-Genus) %>%
  mutate(source = map_meta[name])

rel_abund %>% ggplot(aes(x = source, y = Genus, fill = value)) +
  geom_tile() +
  scale_fill_gradient2(
    name = "Relative abundance",
    mid = "seagreen1", low = "springgreen", high = "seagreen"
  ) +
  labs(
    x = "Source", y = "Genus",
  )

genera <- sklearn %>%
  group_by(Genus) %>%
  count(sort = TRUE)
```

### Functional analysis

```{r}
ko <- read_delim("./results/3-FunctionAnnotation/Jelly_PICRUST2/pathways_out/path_abun_unstrat.tsv", delim = "\t")
functions <- ko %>%
  as.data.frame() %>%
  t() %>%
  `colnames<-`(subset(., grepl("function", rownames(.)))) %>%
  as.data.frame() %>%
  slice(-1) %>%
  mutate_all(as.numeric)
```

## Data sources
- https://www.ebi.ac.uk/ena/browser/view/PRJEB8518
- https://docs.qiime2.org/2023.5/data-resources/ High-quality reference OTUs
- The `see` and `v2frame` functions were obtained from [this](https://forum.qiime2.org/t/how-to-capture-a-value-from-a-summary-and-pipe-it/19783/5) link via user thermokarst
