### Load functions and libraries
```{r}
library(ape)
library(ggtree)
library(TreeDist)
library(phyloseq)
library(tidyverse)
library(glue)
library(qiime2R)

alpha_metrics <- list(
  sh = "shannon", pi = "pielou_e",
  si = "simpson", se = "simpson_e"
)

unique_known <- function(otus, identified, classifier) {
  uniques <- identified %>%
    group_by(taxon) %>%
    summarise() %>%
    dim()
  msg <- "% Unique otus:"
  prop <- round((uniques[1] / dim(otus)[1]) * 100, 2)
  return(glue("{classifier} {msg} {prop}"))
}

get_artifact_data <- function(path, ids, extension) {
  # Generic import function for artifact data
  artifacts <- list()
  for (id in names(ids)) {
    a_path <- glue("{path}/{id}-{extension}.qza")
    artifacts[[id]] <- read_qza(a_path)$data
  }
  return(artifacts)
}

known_taxon <- function(row, taxonomy) {
  known_rank <- 7
  while (is.na(taxonomy[row, known_rank]) && known_rank != 1) {
    known_rank <- known_rank - 1
  }
  return(taxonomy[row, known_rank])
}

genus_level <- function(row, taxonomy) {
  if (is.na(taxonomy[row, 7])) {
    return(taxonomy[row, 6])
  }
  return(taxonomy[row, 7])
}

identify <- function(taxonomy, otus) {
  return(
    lapply(1:nrow(taxonomy), known_taxon, taxonomy = taxonomy) %>%
      unlist() %>%
      data.frame(row.names = rownames(blast), taxon = .) %>%
      merge(., otus, by = 0) %>%
      drop_na()
  )
}
```
### Sample background

#### Importing the data

The fastq files contain single-end reads, sequenced with the 454 GS FLX+ via a pyrosequencing approach
https://trace.ncbi.nlm.nih.gov/Traces/study/?acc=SRP254518&o=acc_s%3Aa&s=SRR11447095,SRR11447093,SRR11447098

```{bash}
qiime tools import \
    --type 'SampleData[SequencesWithQuality]' \
    --input-path data.tsv \
    --output-path jelly.qza \
    --input-format SingleEndFastqManifestPhred33V2
```
### Raw data exploration

The initial data exploration was performed with fastqc. There is a high variation in read length, though the majority are in the 450 - 500 bp range. As expected for short-read sequencing, read quality drops at higher read lengths, necessitating trimming. Surprisingly, the sample has little adapter content.

#### Blasting overrepresenting sequences

To get a rough idea of what microorganisms were represented most in the sample, I used data from `fastqc`'s overrepresented sequences module.
The sequences listed in the module were combined, clustered together to remove redundant reads with `cd-hit`, then blasted against the custom 16s rRNA database.

- `cd-hit` grouped 238 overrepresented sequences from the 7 samples into only 17 clusters
- The following describes the best 3 hits for the top 3 most overrepresented sequences
  - 1. Entoplasma, Mesoplasma, Lebetimonas
  - 2. _Ferruginivarius sediminum_, Azospirillum, Desulfosporosinus
  - 3. Flavobacteria, Dokdonia, Joostella

### Taxonomic classification
For taxonmic classification, I tried out all three of the options offered by qiime2: blast, vsearch and pre-trained naive-bayes classifier. 

### Import results

```{r}
otus <- read_qza("./results/2-OTUs/Jelly-otuFreqs.qza")$data
blast <- read_qza("./results/3-Classified/Jelly-BLAST_All.qza")$data %>%
  parse_taxonomy()
sklearn <- read_qza("./results/3-Classified/Jelly-Sklearn.qza")$data %>%
  parse_taxonomy()
vsearch <- read_qza("./results/3-Classified/Jelly-Vsearch_All.qza")$data %>%
  parse_taxonomy()
iqtree <- read_qza("./results/6-RootedTrees/Jelly-IQTREE_RootedTree.qza")$data

ko <- read_delim("results/3-FunctionAnnotation/Jelly_PICRUST2/KO_metagenome_out//pred_metagenome_unstrat.tsv", delim = "\t")
functions <- ko %>%
  as.data.frame() %>%
  t() %>%
  `colnames<-`(subset(., grepl("function", rownames(.)))) %>%
  as.data.frame() %>%
  slice(-1) %>%
  mutate_all(as.numeric)

b_known <- identify(blast, otus)
unique_known(otus, b_known, classifier = "BLAST")
sk_known <- identify(sklearn, otus)
unique_known(otus, sk_known, classifier = "Sklearn")
v_known <- identify(vsearch, otus)
unique_known(otus, v_known, classifier = "Vsearch")
```
Simply by looking at the proportion of identified, unique otus, we can see that the machine-learning approach is more effective than the homology-based methods (it's also far lighter on computer resources). I'll use the sklearn identifications for the rest of the analysis. 

### Phylogenetic tree

```{r}
iqtree$tip.label <- sk_known$taxon[iqtree$tip.label %in% sk_known$Row.names]
tree <- ggtree(iqtree) + geom_tiplab(size = 3, color = "blue") +
    geom_rootedge(rootedge = .3)
```

### Taxonomic analysis
```{r}
# Which genera were most abundant?
genera <- sklearn %>%
  group_by(Genus) %>%
  count(sort = TRUE)
```

